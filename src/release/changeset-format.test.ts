import { readdirSync, readFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { describe, expect, it } from 'vitest';
import { parse } from 'yaml';

import { CHANGESET_DIR, getChangesetFiles } from './changeset-test-utils.js';

/**
 * Validates that any pending .changeset/*.md files follow the correct format.
 * Ensures changeset files generated by `pnpm changeset` are well-formed.
 *
 * Architecture source: _bmad-output/planning-artifacts/release-infrastructure/architecture.md
 * Story: rel-2-3 (Create Manual Changeset Workflow)
 */

// Known publishable packages in this monorepo
const PUBLISHABLE_PACKAGES = [
  '@zookanalytics/agent-env',
  '@zookanalytics/bmad-orchestrator',
] as const;

const VALID_BUMP_TYPES = ['patch', 'minor', 'major'] as const;

function parseChangesetContent(
  content: string,
  filename: string
): {
  frontmatter: Record<string, string>;
  description: string;
} {
  const match = content.match(/^---\n([\s\S]*?)\n---\s*([\s\S]*)$/);
  if (!match) {
    throw new Error(`Invalid changeset format in ${filename}: missing YAML frontmatter`);
  }

  const frontmatter = parse(match[1]) as Record<string, string>;
  return { frontmatter, description: match[2].trim() };
}

describe('changeset file format', () => {
  it('has a .changeset directory with config.json and README.md', () => {
    const files = readdirSync(CHANGESET_DIR);
    expect(files).toContain('config.json');
    expect(files).toContain('README.md');
  });

  it('all pending changeset files have valid format', () => {
    const changesetFiles = getChangesetFiles();

    for (const file of changesetFiles) {
      const content = readFileSync(resolve(CHANGESET_DIR, file), 'utf-8');
      const { frontmatter, description } = parseChangesetContent(content, file);

      // Must have at least one package entry
      const packages = Object.keys(frontmatter);
      expect(packages.length, `${file} must reference at least one package`).toBeGreaterThan(0);

      // All packages must be known publishable packages
      for (const pkg of packages) {
        expect(
          PUBLISHABLE_PACKAGES as readonly string[],
          `${file} references unknown package "${pkg}"`
        ).toContain(pkg);
      }

      // All bump types must be valid
      for (const [pkg, bump] of Object.entries(frontmatter)) {
        expect(
          VALID_BUMP_TYPES as readonly string[],
          `${file} has invalid bump type "${bump}" for ${pkg}`
        ).toContain(bump);
      }

      // Must have a non-empty description
      expect(description.length, `${file} must have a non-empty description`).toBeGreaterThan(0);
    }
  });
});

describe('parseChangesetContent error handling', () => {
  it('throws error for malformed YAML frontmatter', () => {
    const malformedContent = `---\n"package": invalid:\n---\ndescription`;
    expect(() => parseChangesetContent(malformedContent, 'malformed-test.md')).toThrow();
  });

  it('throws error for changeset file with no frontmatter', () => {
    expect(() => parseChangesetContent('Just a description', 'no-frontmatter-test.md')).toThrow(
      /missing YAML frontmatter/
    );
  });
});

describe('changeset file content validation', () => {
  it('identifies invalid bump types', () => {
    const content = `---\n"@zookanalytics/agent-env": invalidBump\n---\ndescription`;
    const { frontmatter } = parseChangesetContent(content, 'test.md');
    for (const [, bump] of Object.entries(frontmatter)) {
      expect(VALID_BUMP_TYPES as readonly string[]).not.toContain(bump);
    }
  });

  it('identifies unknown packages', () => {
    const content = `---\n"@zookanalytics/unknown-package": patch\n---\ndescription`;
    const { frontmatter } = parseChangesetContent(content, 'test.md');
    for (const pkg of Object.keys(frontmatter)) {
      expect(PUBLISHABLE_PACKAGES as readonly string[]).not.toContain(pkg);
    }
  });

  it('identifies empty description', () => {
    const content = `---\n"@zookanalytics/agent-env": patch\n---\n`;
    const { description } = parseChangesetContent(content, 'test.md');
    expect(description.length).toBe(0);
  });
});
