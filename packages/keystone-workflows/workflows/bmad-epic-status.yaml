$schema: https://raw.githubusercontent.com/mhingston/keystone-cli/main/schemas/workflow.json
name: bmad-epic-status
description: "BMAD epic iterator (Approach B): Use BMAD workflow-status to find and process next story"

inputs:
  epic_id:
    type: string
    description: "Epic ID prefix (e.g., '3c')"
  require_approval:
    type: boolean
    default: true
    description: "If true, require human approval after each story"
  max_stories:
    type: number
    default: 10
    description: "Maximum number of stories to process in one run"
  current_count:
    type: number
    default: 0
    description: "Internal counter for recursion tracking"

outputs:
  stories_processed: ${{ inputs.current_count + 1 }}

steps:
  # Step 1: Query BMAD for next ready-for-dev story in this epic
  - id: getNextStory
    type: shell
    allowInsecure: true
    run: |
      EPIC_ID="${{ inputs.epic_id }}"

      # Use Claude to query BMAD workflow-status for next story
      # This invokes the BMAD sprint-status workflow to find the next actionable story
      RESULT=$(claude -p "Using /bmad:bmm:workflows:sprint-status, find the next story in epic $EPIC_ID that has status 'ready-for-dev' or 'backlog'. Return ONLY the story ID (e.g., '3c-1-story-name') or 'NONE' if no stories are available." --dangerously-skip-permissions --output-format text 2>/dev/null)

      # Clean up the result - extract just the story ID
      STORY_ID=$(echo "$RESULT" | grep -oE "${EPIC_ID}-[0-9]+-[a-zA-Z0-9-]+" | head -1)

      if [ -z "$STORY_ID" ]; then
        printf "no_more_stories"
      else
        printf "%s" "$STORY_ID"
      fi
    timeout: 300000

  # Step 2: Check if we have a story to process
  # Use printf to avoid trailing newline that breaks string comparison
  - id: checkNext
    type: shell
    needs: [getNextStory]
    allowInsecure: true
    run: |
      if [ "${{ steps.getNextStory.output }}" = "no_more_stories" ]; then
        printf "no_more_stories"
      else
        printf "has_story"
      fi

  # Step 3: Process the story (if found)
  - id: processStory
    type: workflow
    needs: [checkNext]
    if: ${{ steps.checkNext.output == 'has_story' }}
    path: bmad-story.yaml
    inputs:
      story_id: ${{ steps.getNextStory.output }}
      require_approval: ${{ inputs.require_approval }}
    outputMapping:
      success: success
      story_id: story_id
      commit_hash: commit_hash
      error_step: error_step

  # Step 4: Check if we should continue iterating
  - id: shouldContinue
    type: shell
    needs: [processStory]
    if: ${{ steps.checkNext.output == 'has_story' }}
    allowInsecure: true
    run: |
      CURRENT=${{ inputs.current_count }}
      MAX=${{ inputs.max_stories }}
      NEXT=$((CURRENT + 1))

      if [ "$NEXT" -ge "$MAX" ]; then
        printf "max_reached"
      elif [ "${{ steps.processStory.output.success }}" != "true" ]; then
        printf "story_failed"
      else
        printf "continue"
      fi

  # Step 5: Recursive call to process next story
  - id: iterate
    type: workflow
    needs: [shouldContinue]
    if: ${{ steps.shouldContinue.output == 'continue' }}
    path: bmad-epic-status.yaml
    inputs:
      epic_id: ${{ inputs.epic_id }}
      require_approval: ${{ inputs.require_approval }}
      max_stories: ${{ inputs.max_stories }}
      current_count: ${{ inputs.current_count + 1 }}
    outputMapping:
      completed_stories: completed_stories
      stories_processed: stories_processed
      stopped_reason: stopped_reason

  # Step 6: Final summary (only on termination - when no recursion happens)
  # Only needs checkNext since other steps are conditional and may not run
  - id: finalSummary
    type: human
    needs: [checkNext]
    if: ${{ steps.checkNext.output == 'no_more_stories' || (steps.shouldContinue.output && steps.shouldContinue.output != 'continue') }}
    message: |
      Epic ${{ inputs.epic_id }} Processing Complete (Approach B)

      ═══════════════════════════════════════

      Reason for stopping: ${{ steps.checkNext.output == 'no_more_stories' ? 'All stories complete' : steps.shouldContinue.output == 'max_reached' ? 'Maximum stories reached' : 'Story failed' }}

      Stories processed this run: ${{ inputs.current_count + 1 }}

      Last story: ${{ steps.getNextStory.output }}

      ═══════════════════════════════════════

      Run again to continue with remaining stories?
    inputType: confirm
